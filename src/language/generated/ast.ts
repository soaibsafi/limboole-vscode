/******************************************************************************
 * This file was generated by langium-cli 3.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import type { AstNode, ReferenceInfo, TypeMetaData } from 'langium';
import { AbstractAstReflection } from 'langium';

export const LimbooleTerminals = {
    VAR: /([a-zA-Z0-9_\-\.\[\]\$\@]*[a-zA-Z0-9_\.\[\]\$\@])/,
    SL_COMMENT: /%[^\n\r]*/,
    WS: /\s+/,
};

export type LimbooleTerminalNames = keyof typeof LimbooleTerminals;

export type LimbooleKeywordNames = 
    | "!"
    | "&"
    | "("
    | ")"
    | "->"
    | "<-"
    | "<->"
    | "|";

export type LimbooleTokenNames = LimbooleTerminalNames | LimbooleKeywordNames;

export interface Expr extends AstNode {
    readonly $type: 'And' | 'Expr' | 'Iff' | 'Implies' | 'Or';
    var: string;
}

export const Expr = 'Expr';

export function isExpr(item: unknown): item is Expr {
    return reflection.isInstance(item, Expr);
}

export interface And extends Expr {
    readonly $type: 'And';
    left: Expr;
    right: Expr;
}

export const And = 'And';

export function isAnd(item: unknown): item is And {
    return reflection.isInstance(item, And);
}

export interface Iff extends Expr {
    readonly $type: 'Iff';
    left: Expr;
    right: Expr;
}

export const Iff = 'Iff';

export function isIff(item: unknown): item is Iff {
    return reflection.isInstance(item, Iff);
}

export interface Implies extends Expr {
    readonly $type: 'Implies';
    left: Expr;
    right: Expr;
}

export const Implies = 'Implies';

export function isImplies(item: unknown): item is Implies {
    return reflection.isInstance(item, Implies);
}

export interface Or extends Expr {
    readonly $type: 'Or';
    left: Expr;
    right: Expr;
}

export const Or = 'Or';

export function isOr(item: unknown): item is Or {
    return reflection.isInstance(item, Or);
}

export type LimbooleAstType = {
    And: And
    Expr: Expr
    Iff: Iff
    Implies: Implies
    Or: Or
}

export class LimbooleAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return [And, Expr, Iff, Implies, Or];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case And:
            case Iff:
            case Implies:
            case Or: {
                return this.isSubtype(Expr, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case Expr: {
                return {
                    name: Expr,
                    properties: [
                        { name: 'var' }
                    ]
                };
            }
            case And: {
                return {
                    name: And,
                    properties: [
                        { name: 'left' },
                        { name: 'right' },
                        { name: 'var' }
                    ]
                };
            }
            case Iff: {
                return {
                    name: Iff,
                    properties: [
                        { name: 'left' },
                        { name: 'right' },
                        { name: 'var' }
                    ]
                };
            }
            case Implies: {
                return {
                    name: Implies,
                    properties: [
                        { name: 'left' },
                        { name: 'right' },
                        { name: 'var' }
                    ]
                };
            }
            case Or: {
                return {
                    name: Or,
                    properties: [
                        { name: 'left' },
                        { name: 'right' },
                        { name: 'var' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}

export const reflection = new LimbooleAstReflection();
